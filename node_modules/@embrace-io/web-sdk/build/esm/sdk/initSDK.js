import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
import { logs } from '@opentelemetry/api-logs';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { emptyResource } from '@opentelemetry/resources';
import { BatchLogRecordProcessor, LoggerProvider } from '@opentelemetry/sdk-logs';
import { BatchSpanProcessor, WebTracerProvider, StackContextManager } from '@opentelemetry/sdk-trace-web';
import { isValidAppID } from './utils.js';
import { setupDefaultInstrumentations } from './setupDefaultInstrumentations.js';
import { createSessionSpanProcessor } from '@opentelemetry/web-common';
import { registry } from './registry.js';
import { getDefaultAttributeScrubbers } from './defaultAttributeScrubbers.js';
import { OTelPerformanceManager } from '../utils/PerformanceManager/OTelPerformanceManager.js';
import { getWebSDKResource } from '../resources/webSdkResource.js';
import { EmbraceDynamicConfigManager } from '../managers/EmbraceConfigManager/EmbraceDynamicConfigManager.js';
import { EmbraceSDKFeaturesManager } from '../managers/EmbraceSDKFeaturesManager/EmbraceSDKFeaturesManager.js';
import { nsfConfigValidation } from '../utils/nsfConfigValidation.js';
import { EmbraceLimitManager } from '../managers/EmbraceLimitManager/EmbraceLimitManager.js';
import { DEFAULT_LIMITS } from '../managers/EmbraceLimitManager/constants.js';
import { EmbraceSessionBatchedSpanProcessor } from '../processors/EmbraceSessionBatchedSpanProcessor/EmbraceSessionBatchedSpanProcessor.js';
import { EmbraceTraceExporter } from '../exporters/EmbraceTraceExporter/EmbraceTraceExporter.js';
import { EmbraceLogExporter } from '../exporters/EmbraceLogExporter/EmbraceLogExporter.js';
import { EmbraceW3CTraceContextPropagator } from '../propagators/EmbraceW3CTraceContextPropagator/EmbraceW3CTraceContextPropagator.js';
import { EmbraceUserManager } from '../managers/EmbraceUserManager/EmbraceUserManager.js';
import { user } from '../api-users/userAPI.js';
import { EmbraceSpanSessionManager } from '../managers/EmbraceSpanSessionManager/EmbraceSpanSessionManager.js';
import { session } from '../api-sessions/sessionAPI.js';
import { EmbraceNetworkSpanProcessor } from '../processors/EmbraceNetworkSpanProcessor/EmbraceNetworkSpanProcessor.js';
import { UserSpanProcessor } from '../processors/UserSpanProcessor/UserSpanProcessor.js';
import { SpanScrubProcessor } from '../processors/SpanScrubProcessor/SpanScrubProcessor.js';
import { EmbraceTraceManager } from '../managers/EmbraceTraceManager/EmbraceTraceManager.js';
import { trace } from '../api-traces/traceAPI.js';
import { IdentifiableSessionLogRecordProcessor } from '../processors/IdentifiableSessionLogRecordProcessor/IdentifiableSessionLogRecordProcessor.js';
import { EmbraceLogRecordProcessor } from '../processors/EmbraceLogRecordProcessor/EmbraceLogRecordProcessor.js';
import { UserLogRecordProcessor } from '../processors/UserLogRecordProcessor/UserLogRecordProcessor.js';
import { LogRecordScrubProcessor } from '../processors/LogRecordScrubProcessor/LogRecordScrubProcessor.js';
import { EmbraceLogManager } from '../managers/EmbraceLogManager/EmbraceLogManager.js';
import { log } from '../api-logs/logAPI.js';

const initSDK = ({ appID, appVersion, resource = emptyResource(), spanExporters = [], logExporters = [], spanProcessors = [], propagator = null, defaultInstrumentationConfig, instrumentations = [], contextManager = null, logProcessors = [], attributeScrubbers = [], enableDefaultAttributeScrubbing = true, additionalQueryParamsToScrub = [], logLevel = DiagLogLevel.ERROR, embraceDataURL, embraceConfigURL, diagLogger = diag.createComponentLogger({
    namespace: 'embrace-sdk'
}), dynamicSDKConfigManager: providedDynamicSDKConfigManager, dynamicSDKConfig, registerGlobally = true, blockNetworkSpanForwarding = false } = {
    appID: ''
})=>{
    try {
        const perf = new OTelPerformanceManager();
        const initSDKStart = perf.getNowMillis();
        if (registerGlobally) {
            const existingSDK = registry.registered();
            if (existingSDK !== null) {
                diagLogger.warn('SDK has already been successfully initialized, skipping this invocation of initSDK');
                return existingSDK;
            }
        }
        diag.setLogger(new DiagConsoleLogger(), {
            logLevel
        });
        const resourceWithWebSDKAttributes = resource.merge(getWebSDKResource({
            diagLogger,
            appVersion,
            pageSessionStorage: window.sessionStorage
        }));
        const sendingToEmbrace = !!appID && isValidAppID(appID);
        if (!sendingToEmbrace && !logExporters.length && !spanExporters.length) {
            throw new Error('when the embrace appID is omitted then at least one logExporter or spanExporter must be set');
        }
        const userManager = setupUser({
            registerGlobally
        });
        const enduserPseudoID = userManager.getEmbraceUserId();
        if (sendingToEmbrace && !enduserPseudoID) {
            throw new Error('userID is required when using Embrace exporter');
        }
        const dynamicConfigManager = providedDynamicSDKConfigManager ?? new EmbraceDynamicConfigManager({
            appID,
            appVersion,
            embraceConfigURL,
            defaultConfig: dynamicSDKConfig,
            deviceId: enduserPseudoID
        });
        void dynamicConfigManager.refreshRemoteConfig();
        const sdkFeaturesManager = new EmbraceSDKFeaturesManager({
            dynamicConfigManager,
            deviceId: enduserPseudoID,
            blockNetworkSpanForwarding
        });
        if (!sdkFeaturesManager.isSDKEnabled()) {
            diagLogger.debug('SDK is disabled, skipping initialization.');
            return false;
        }
        const nsfValid = nsfConfigValidation({
            featureManager: sdkFeaturesManager,
            diag: diagLogger,
            registerGlobally,
            defaultInstrumentationConfig,
            propagator
        });
        const limitManager = new EmbraceLimitManager(DEFAULT_LIMITS);
        const finalAttributeScrubbers = [
            ...enableDefaultAttributeScrubbing ? getDefaultAttributeScrubbers(additionalQueryParamsToScrub) : [],
            ...attributeScrubbers
        ];
        const spanSessionManager = setupSession({
            limitManager,
            registerGlobally
        });
        let embraceSpanProcessor;
        let embraceLogProcessor;
        if (sendingToEmbrace) {
            embraceSpanProcessor = new EmbraceSessionBatchedSpanProcessor({
                exporter: new EmbraceTraceExporter({
                    appID,
                    embraceDataURL,
                    userID: enduserPseudoID
                }),
                limitManager,
                storedSpansExpireTimeoutMS: defaultInstrumentationConfig?.['session-visibility']?.storedSpansExpireTimeoutMS
            });
            embraceLogProcessor = new BatchLogRecordProcessor(new EmbraceLogExporter({
                appID,
                embraceDataURL,
                userID: enduserPseudoID
            }));
        }
        const { tracerProvider, embraceTraceManager } = setupTraces({
            resource: resourceWithWebSDKAttributes,
            spanSessionManager,
            userManager,
            spanExporters,
            spanProcessors,
            propagator: nsfValid ? new EmbraceW3CTraceContextPropagator() : propagator,
            contextManager,
            attributeScrubbers: finalAttributeScrubbers,
            registerGlobally,
            embraceSpanProcessor
        });
        spanSessionManager.setTracerProvider(tracerProvider);
        const { loggerProvider, embraceLogManager } = setupLogs({
            resource: resourceWithWebSDKAttributes,
            userManager,
            logExporters,
            logProcessors,
            spanSessionManager,
            limitManager,
            attributeScrubbers: finalAttributeScrubbers,
            registerGlobally,
            embraceLogProcessor
        });
        // NOTE: we require setupInstrumentation to run the last, after setupLogs and setupTraces. This is how OTel works wrt
        // the dependencies between instrumentations and global providers. We need the providers for tracers, and logs to be
        // setup before we enable instrumentations.
        if (!registerGlobally) {
            registerInstrumentations({
                tracerProvider,
                loggerProvider,
                instrumentations: [
                    setupDefaultInstrumentations(defaultInstrumentationConfig, {
                        logManager: embraceLogManager,
                        spanSessionManager,
                        embraceSpanProcessor
                    }),
                    ...instrumentations
                ]
            });
        } else {
            registerInstrumentations({
                instrumentations: [
                    setupDefaultInstrumentations(defaultInstrumentationConfig, {
                        embraceSpanProcessor
                    }),
                    ...instrumentations
                ]
            });
        }
        diagLogger.info('successfully initialized the SDK');
        const sdkControl = {
            setDynamicConfig: (config)=>{
                dynamicConfigManager.setConfig(config);
            },
            flush: async ()=>{
                await tracerProvider.forceFlush();
                await loggerProvider.forceFlush();
            },
            log: embraceLogManager,
            trace: embraceTraceManager,
            session: spanSessionManager,
            user: userManager
        };
        if (registerGlobally) {
            registry.register(sdkControl);
        }
        spanSessionManager.recordSDKStartupDuration(perf.getNowMillis() - initSDKStart);
        return sdkControl;
    } catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown error.';
        diagLogger.error(`failed to initialize the SDK: ${message}`);
        return false;
    }
};
const setupUser = ({ registerGlobally })=>{
    const embraceUserManager = new EmbraceUserManager();
    if (registerGlobally) {
        user.setGlobalUserManager(embraceUserManager);
    }
    return embraceUserManager;
};
const setupSession = ({ limitManager, registerGlobally })=>{
    const embraceSpanSessionManager = new EmbraceSpanSessionManager({
        limitManager
    });
    if (registerGlobally) {
        session.setGlobalSessionManager(embraceSpanSessionManager);
    }
    return embraceSpanSessionManager;
};
const setupTraces = ({ resource, spanSessionManager, userManager, spanExporters, spanProcessors = [], propagator = null, contextManager = null, attributeScrubbers, registerGlobally, embraceSpanProcessor })=>{
    const finalSpanProcessors = [
        ...spanProcessors,
        createSessionSpanProcessor(spanSessionManager),
        new EmbraceNetworkSpanProcessor(),
        new UserSpanProcessor({
            userManager
        }),
        new SpanScrubProcessor({
            attributeScrubbers
        })
    ];
    spanExporters?.forEach((exporter)=>{
        finalSpanProcessors.push(new BatchSpanProcessor(exporter));
    });
    if (embraceSpanProcessor) {
        finalSpanProcessors.push(embraceSpanProcessor);
    }
    const tracerProvider = new WebTracerProvider({
        resource,
        spanProcessors: finalSpanProcessors,
        spanLimits: {
            // Session properties are stored as attributes on the session span, add a
            // buffer here so that there is room for our internal attributes
            attributeCountLimit: DEFAULT_LIMITS.maxAllowed.session_property * 2,
            attributePerEventCountLimit: 20,
            // Breadcrumbs are stored as events on the session span, add a
            // buffer here so that there is room for our internal events
            eventCountLimit: DEFAULT_LIMITS.maxAllowed.breadcrumb * 2,
            attributeValueLengthLimit: 1024
        }
    });
    const embraceTraceManager = new EmbraceTraceManager({
        tracerProvider: registerGlobally ? undefined : tracerProvider
    });
    if (registerGlobally) {
        trace.setGlobalTraceManager(embraceTraceManager);
        tracerProvider.register({
            // WebTracerProvider.register has different fallback behaviours depending on whether null or undefined is passed,
            // be more explicit here and always supply a StackContextManager if the config did not specify one. If a user really
            // wants to turn off context management they can pass a no-op manager explicitly:
            // https://github.com/open-telemetry/opentelemetry-js/blob/4f0b6285af24b71a9fa022755aaa3b6a63ae5033/packages/opentelemetry-sdk-trace-web/src/WebTracerProvider.ts#L39
            contextManager: contextManager || new StackContextManager(),
            propagator
        });
    }
    return {
        tracerProvider,
        embraceTraceManager
    };
};
const setupLogs = ({ resource, userManager, logExporters, logProcessors, spanSessionManager, limitManager, attributeScrubbers, registerGlobally, embraceLogProcessor })=>{
    const finalLogProcessors = [
        ...logProcessors,
        new IdentifiableSessionLogRecordProcessor({
            spanSessionManager
        }),
        new EmbraceLogRecordProcessor(),
        new UserLogRecordProcessor({
            userManager
        }),
        new LogRecordScrubProcessor({
            attributeScrubbers
        })
    ];
    logExporters?.forEach((exporter)=>{
        finalLogProcessors.push(new BatchLogRecordProcessor(exporter));
    });
    if (embraceLogProcessor) {
        finalLogProcessors.push(embraceLogProcessor);
    }
    const loggerProvider = new LoggerProvider({
        resource,
        processors: finalLogProcessors
    });
    const embraceLogManager = new EmbraceLogManager({
        spanSessionManager,
        limitManager,
        loggerProvider: registerGlobally ? undefined : loggerProvider
    });
    if (registerGlobally) {
        logs.setGlobalLoggerProvider(loggerProvider);
        log.setGlobalLogManager(embraceLogManager);
    }
    return {
        loggerProvider,
        embraceLogManager
    };
};

export { initSDK };
//# sourceMappingURL=initSDK.js.map
