import { context, propagation, ROOT_CONTEXT, trace } from '@opentelemetry/api';
import { TRACE_PARENT_HEADER } from '@opentelemetry/core';
import { safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';
import { PerformanceTimingNames, addSpanNetworkEvents, addSpanNetworkEvent, hasKey } from '@opentelemetry/sdk-trace-web';
import { AttributeNames } from './enums/AttributeNames.js';
import { ATTR_URL_FULL, ATTR_USER_AGENT_ORIGINAL, ATTR_HTTP_RESPONSE_BODY_SIZE, ATTR_HTTP_RESPONSE_SIZE } from '@opentelemetry/semantic-conventions/incubating';
import { getPerformanceNavigationEntries, addSpanPerformancePaintEvents } from './utils.js';
import { ATTR_HTTP_RESPONSE_STATUS_CODE } from '@opentelemetry/semantic-conventions';
import { EmbraceInstrumentationBase } from '../../EmbraceInstrumentationBase/EmbraceInstrumentationBase.js';
import { KEY_EMB_TYPE, EMB_TYPES } from '../../../constants/attributes.js';

const ATTR_DELIVERY_TYPE = 'delivery_type';
const ATTR_ENTRY_TYPE = 'entry_type';
const ATTR_INITIATOR_TYPE = 'initiator_type';
const ATTR_RENDER_BLOCKING_STATUS = 'render_blocking_status';
const ATTR_DECODED_BODY_SIZE = 'decoded_body_size';
class DocumentLoadInstrumentation extends EmbraceInstrumentationBase {
    constructor({ diag, perf, enabled, applyCustomAttributesOnSpan, ignorePerformancePaintEvents = false, ignoreNetworkEvents = false } = {}){
        super({
            instrumentationName: 'DocumentLoadInstrumentation',
            instrumentationVersion: '1.0.0',
            diag,
            perf,
            config: {
                enabled,
                applyCustomAttributesOnSpan,
                ignorePerformancePaintEvents,
                ignoreNetworkEvents
            }
        });
        this._onDocumentLoaded = ()=>{
            // Timeout is needed as load event doesn't have yet the performance metrics for loadEnd
            window.setTimeout(()=>{
                this._collectPerformance();
            }, 0);
        };
        if (this._config.enabled) {
            this.enable();
        }
    }
    init() {
        this._diag.debug('Initializing document load instrumentation');
        return undefined;
    }
    /**
   * Adds spans for all resources
   * @param rootSpan
   */ _addResourcesSpans(rootSpan) {
        const resources = performance.getEntriesByType('resource');
        resources.forEach((resource)=>{
            this._initResourceSpan(resource, rootSpan);
        });
    }
    /**
   * Collects information about performance and creates appropriate spans
   */ _collectPerformance() {
        const metaElement = Array.from(document.getElementsByTagName('meta')).find((e)=>e.getAttribute('name') === TRACE_PARENT_HEADER);
        const entries = getPerformanceNavigationEntries();
        const traceparent = metaElement && metaElement.content || '';
        context.with(propagation.extract(ROOT_CONTEXT, {
            traceparent
        }), ()=>{
            const rootSpan = this._startSpan(AttributeNames.DOCUMENT_LOAD, PerformanceTimingNames.FETCH_START, entries);
            if (!rootSpan) {
                return;
            }
            context.with(trace.setSpan(context.active(), rootSpan), ()=>{
                const fetchSpan = this._startSpan(AttributeNames.DOCUMENT_FETCH, PerformanceTimingNames.FETCH_START, entries);
                if (fetchSpan) {
                    fetchSpan.setAttribute(ATTR_URL_FULL, location.href);
                    context.with(trace.setSpan(context.active(), fetchSpan), ()=>{
                        addSpanNetworkEvents(fetchSpan, entries, this.getConfig().ignoreNetworkEvents);
                        this._addCustomAttributesOnSpan(fetchSpan, this.getConfig().applyCustomAttributesOnSpan?.documentFetch);
                        this._endSpan(fetchSpan, PerformanceTimingNames.RESPONSE_END, entries);
                    });
                }
            });
            rootSpan.setAttribute(KEY_EMB_TYPE, EMB_TYPES.DocumentLoad);
            rootSpan.setAttribute(ATTR_URL_FULL, location.href);
            rootSpan.setAttribute(ATTR_USER_AGENT_ORIGINAL, navigator.userAgent);
            this._addResourcesSpans(rootSpan);
            if (!this.getConfig().ignoreNetworkEvents) {
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.FETCH_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_END, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_INTERACTIVE, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_END, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_COMPLETE, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
            }
            if (!this.getConfig().ignorePerformancePaintEvents) {
                addSpanPerformancePaintEvents(rootSpan);
            }
            this._addCustomAttributesOnSpan(rootSpan, this.getConfig().applyCustomAttributesOnSpan?.documentLoad);
            this._endSpan(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
        });
    }
    /**
   * Helper function for ending span
   * @param span
   * @param performanceName name of performance entry for time end
   * @param entries
   */ // eslint-disable-next-line @typescript-eslint/class-methods-use-this
    _endSpan(span, performanceName, entries) {
        // span can be undefined when entries are missing the certain performance - the span will not be created
        if (span) {
            if (hasKey(entries, performanceName) && typeof entries[performanceName] === 'number') {
                span.end(entries[performanceName]);
            } else {
                span.end();
            }
        }
    }
    /**
   * Creates and ends a span with network information about resource added as timed events
   * @param resource
   * @param parentSpan
   */ _initResourceSpan(resource, parentSpan) {
        const span = this._startSpan(AttributeNames.RESOURCE_FETCH, PerformanceTimingNames.FETCH_START, resource, parentSpan);
        if (span) {
            span.setAttribute(KEY_EMB_TYPE, EMB_TYPES.ResourceFetch);
            span.setAttribute(ATTR_URL_FULL, resource.name);
            addSpanNetworkEvents(span, resource, this.getConfig().ignoreNetworkEvents);
            if (resource.deliveryType) {
                span.setAttribute(ATTR_DELIVERY_TYPE, resource.deliveryType);
            }
            span.setAttribute(ATTR_ENTRY_TYPE, resource.entryType);
            span.setAttribute(ATTR_INITIATOR_TYPE, resource.initiatorType);
            if (resource.renderBlockingStatus) {
                span.setAttribute(ATTR_RENDER_BLOCKING_STATUS, resource.renderBlockingStatus);
            }
            span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, resource.responseStatus);
            span.setAttribute(ATTR_HTTP_RESPONSE_BODY_SIZE, resource.encodedBodySize);
            span.setAttribute(ATTR_HTTP_RESPONSE_SIZE, resource.transferSize);
            span.setAttribute(ATTR_DECODED_BODY_SIZE, resource.decodedBodySize);
            this._addCustomAttributesOnResourceSpan(span, resource, this.getConfig().applyCustomAttributesOnSpan?.resourceFetch);
            this._endSpan(span, PerformanceTimingNames.RESPONSE_END, resource);
        }
    }
    /**
   * Helper function for starting a span
   * @param spanName name of span
   * @param performanceName name of performance entry for time start
   * @param entries
   * @param parentSpan
   */ _startSpan(spanName, performanceName, entries, parentSpan) {
        if (hasKey(entries, performanceName) && typeof entries[performanceName] === 'number') {
            const span = this.tracer.startSpan(spanName, {
                startTime: entries[performanceName]
            }, parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined);
            return span;
        }
        return undefined;
    }
    /**
   * executes callback {_onDocumentLoaded} when the page is loaded
   */ _waitForPageLoad() {
        if (window.document.readyState === 'complete') {
            this._onDocumentLoaded();
        } else {
            window.addEventListener('load', this._onDocumentLoaded);
        }
    }
    /**
   * adds custom attributes to root span if configured
   */ _addCustomAttributesOnSpan(span, applyCustomAttributesOnSpan) {
        if (applyCustomAttributesOnSpan) {
            safeExecuteInTheMiddle(()=>{
                applyCustomAttributesOnSpan(span);
            }, (error)=>{
                if (!error) {
                    return;
                }
                this._diag.error('addCustomAttributesOnSpan', error);
            }, true);
        }
    }
    /**
   * adds custom attributes to span if configured
   */ _addCustomAttributesOnResourceSpan(span, resource, applyCustomAttributesOnSpan) {
        if (applyCustomAttributesOnSpan) {
            safeExecuteInTheMiddle(()=>{
                applyCustomAttributesOnSpan(span, resource);
            }, (error)=>{
                if (!error) {
                    return;
                }
                this._diag.error('addCustomAttributesOnResourceSpan', error);
            }, true);
        }
    }
    enable() {
        window.removeEventListener('load', this._onDocumentLoaded);
        this._waitForPageLoad();
    }
    disable() {
        window.removeEventListener('load', this._onDocumentLoaded);
    }
}

export { DocumentLoadInstrumentation };
//# sourceMappingURL=DocumentLoadInstrumentation.js.map
