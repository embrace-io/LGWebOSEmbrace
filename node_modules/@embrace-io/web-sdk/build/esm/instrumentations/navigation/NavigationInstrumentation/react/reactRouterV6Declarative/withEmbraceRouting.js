import React__default from 'react';
import hoistNonReactStatics from 'hoist-non-react-statics';
import { getNavigationInstrumentation } from '../../instance.js';
import { EMB_NAVIGATION_INSTRUMENTATIONS } from '../../../../../constants/attributes.js';

// Routes can be nested, we need to traverse the routeContext to find the last route
const getLastRoute = (matchedComponent, lastRoute)=>{
    if (!matchedComponent.props.match || !matchedComponent.props.match.route) {
        return null;
    }
    const path = lastRoute ? `${lastRoute.path}/${matchedComponent.props.match.route.path}` : matchedComponent.props.match.route.path;
    if (matchedComponent.props.routeContext?.outlet) {
        return getLastRoute(matchedComponent.props.routeContext.outlet, {
            path,
            url: matchedComponent.props.match.pathname
        });
    }
    return {
        path,
        url: matchedComponent.props.match.pathname
    };
};
const withEmbraceRouting = (WrappedComponent)=>{
    const navigationInstrumentation = getNavigationInstrumentation();
    navigationInstrumentation.setInstrumentationType(EMB_NAVIGATION_INSTRUMENTATIONS.Declarative);
    const RoutesWithEmbraceRouting = (props)=>{
        /**
     * React-router v6+ implementation is very different from v5
     * It doesn't have a <Switch> component that injects props into <Route>
     * Instead, it has <Routes> which internally calculates the matched route
     * and returns it as a children, <Route> cannot be wrapped since it requires all children to be a <Route> component
     * here we rely on that matching to get the current route.
     * It's not ideal to rely on internal implementation details, but it's the easier way of getting the current route
     * without having to manually match it or using hooks on each children component
     *
     * See: https://github.com/remix-run/react-router/blob/main/packages/react-router/lib/hooks.tsx#L553
     */ const matchedComponent = WrappedComponent(props);
        if (matchedComponent.props.match && matchedComponent.props.match.route) {
            const lastRoute = getLastRoute(matchedComponent, null);
            if (lastRoute) {
                navigationInstrumentation.setCurrentRoute(lastRoute);
            }
        }
        return React__default.createElement(WrappedComponent, props);
    };
    // Keep wrapped component metadata
    RoutesWithEmbraceRouting.displayName = `withEmbraceRouting(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;
    hoistNonReactStatics(RoutesWithEmbraceRouting, WrappedComponent);
    return RoutesWithEmbraceRouting;
};

export { withEmbraceRouting };
//# sourceMappingURL=withEmbraceRouting.js.map
