import { WEB_VITALS_ID_TO_LISTENER, CORE_WEB_VITALS, ALL_WEB_VITALS, EMB_WEB_VITALS_PREFIX } from './constants.js';
import { ATTR_URL_FULL } from '@opentelemetry/semantic-conventions';
import { EmbraceInstrumentationBase } from '../../EmbraceInstrumentationBase/EmbraceInstrumentationBase.js';
import { EMB_TYPES, KEY_EMB_TYPE } from '../../../constants/attributes.js';

const webVitalAttributionToReport = (name, metric)=>{
    const attributes = {};
    const toReport = [];
    if (name === 'CLS') {
        // https://www.npmjs.com/package/web-vitals#CLSAttribution
        const attribution = metric.attribution;
        toReport.push(...[
            {
                key: 'largestShiftTarget',
                value: attribution.largestShiftTarget
            },
            {
                key: 'largestShiftValue',
                value: attribution.largestShiftValue
            }
        ]);
    } else if (name === 'INP') {
        // https://www.npmjs.com/package/web-vitals#inpattribution
        const attribution = metric.attribution;
        toReport.push(...[
            {
                key: 'interactionTarget',
                value: attribution.interactionTarget
            },
            {
                key: 'interactionType',
                value: attribution.interactionType
            },
            {
                key: 'nextPaintTime',
                value: attribution.nextPaintTime
            },
            {
                key: 'inputDelay',
                value: attribution.inputDelay
            },
            {
                key: 'processingDuration',
                value: attribution.processingDuration
            },
            {
                key: 'presentationDelay',
                value: attribution.presentationDelay
            },
            {
                key: 'totalScriptDuration',
                value: attribution.totalScriptDuration
            },
            {
                key: 'totalStyleAndLayoutDuration',
                value: attribution.totalStyleAndLayoutDuration
            },
            {
                key: 'totalPaintDuration',
                value: attribution.totalPaintDuration
            },
            {
                key: 'totalUnattributedDuration',
                value: attribution.totalUnattributedDuration
            },
            {
                key: 'loadState',
                value: attribution.loadState
            }
        ]);
    } else if (name === 'LCP') {
        // https://www.npmjs.com/package/web-vitals#lcpattribution
        const attribution = metric.attribution;
        toReport.push(...[
            {
                key: 'target',
                value: attribution.target
            },
            {
                key: 'url',
                value: attribution.url
            },
            {
                key: 'timeToFirstByte',
                value: attribution.timeToFirstByte
            },
            {
                key: 'resourceLoadDelay',
                value: attribution.resourceLoadDelay
            },
            {
                key: 'resourceLoadDuration',
                value: attribution.resourceLoadDuration
            },
            {
                key: 'elementRenderDelay',
                value: attribution.elementRenderDelay
            }
        ]);
    }
    toReport.forEach((report)=>{
        if (report.value !== undefined) {
            attributes[`emb.web_vital.attribution.${report.key}`] = report.value;
        }
    });
    return attributes;
};
class WebVitalsInstrumentation extends EmbraceInstrumentationBase {
    // instrumentation that adds an event to the session span for each web vital report
    constructor({ diag, perf, trackingLevel = 'core', listeners = WEB_VITALS_ID_TO_LISTENER, urlDocument = window.document, urlAttribution = true } = {}){
        super({
            instrumentationName: 'WebVitalsInstrumentation',
            instrumentationVersion: '1.0.0',
            diag,
            perf,
            config: {}
        }), this._attributedURL = {
            INP: undefined,
            LCP: undefined,
            CLS: undefined,
            FCP: undefined,
            TTFB: undefined
        };
        this._listeners = listeners;
        this._urlDocument = urlDocument;
        this._metricsToTrack = trackingLevel === 'core' ? [
            ...CORE_WEB_VITALS
        ] : [
            ...ALL_WEB_VITALS
        ];
        this._urlAttribution = urlAttribution;
        if (this._config.enabled) {
            this.enable();
        }
    }
    disable() {
    // do nothing.
    // https://github.com/GoogleChrome/web-vitals/issues/357#issuecomment-1593439036
    }
    enable() {
        this._metricsToTrack.forEach((name)=>{
            this._listeners[name]?.((metric)=>{
                const currentSessionSpan = this.sessionManager.getSessionSpan();
                if (!currentSessionSpan) {
                    return;
                }
                // first thing record the time when this cb was invoked
                const metricTime = this._getTimeForMetric(metric);
                const attrs = {
                    [KEY_EMB_TYPE]: EMB_TYPES.WebVital,
                    [ATTR_URL_FULL]: this._getAttributedURLForMetric(metric),
                    'emb.web_vital.navigation_type': metric.navigationType,
                    'emb.web_vital.name': metric.name,
                    'emb.web_vital.rating': metric.rating,
                    'emb.web_vital.id': metric.id,
                    'emb.web_vital.delta': metric.delta,
                    'emb.web_vital.value': metric.value,
                    ...webVitalAttributionToReport(name, metric)
                };
                currentSessionSpan.addEvent(`${EMB_WEB_VITALS_PREFIX}-report-${name}`, attrs, metricTime);
            });
        });
        if (this._urlAttribution) {
            // When these web vitals make their final report (e.g. when the listeners w/ reportAllChanges=false trigger) the
            // document's URL at that time may not match what it was at the time the scores were last updated. Instead, listen
            // for updates to the scores and keep track of the URL to attribute for each
            this._listeners.INP?.(()=>{
                this._attributedURL.INP = this._urlDocument.URL;
            }, {
                reportAllChanges: true
            });
            this._listeners.LCP?.(()=>{
                this._attributedURL.LCP = this._urlDocument.URL;
            }, {
                reportAllChanges: true
            });
            this._listeners.CLS?.((metric)=>{
                const clsMetric = metric;
                // A layout shift could cause CLS to change its rating but because the score is cumulative this might not
                // correspond with an updated `largestShiftTarget`. Since we want to tie the attributed URL to the page that
                // the `largestShiftTarget` was on we only update the attributed URL if that target has changed
                if (this._largestShiftTargetForCLS !== clsMetric.attribution.largestShiftTarget) {
                    this._largestShiftTargetForCLS = clsMetric.attribution.largestShiftTarget;
                    this._attributedURL.CLS = this._urlDocument.URL;
                }
            }, {
                reportAllChanges: true
            });
        }
    }
    _getTimeForMetric(metric) {
        if (metric.name === 'CLS' && metric.attribution.largestShiftTime) {
            return this.perf.epochMillisFromOriginOffset(metric.attribution.largestShiftTime);
        }
        if (metric.name === 'INP' && metric.attribution.interactionTime) {
            return this.perf.epochMillisFromOriginOffset(metric.attribution.interactionTime);
        }
        return this.perf.getNowMillis();
    }
    _getAttributedURLForMetric(metric) {
        if (metric.name === 'INP' && this._attributedURL.INP) {
            return this._attributedURL.INP;
        }
        if (metric.name === 'LCP' && this._attributedURL.LCP) {
            return this._attributedURL.LCP;
        }
        if (metric.name === 'CLS' && this._attributedURL.CLS && metric.attribution.largestShiftTarget === this._largestShiftTargetForCLS) {
            return this._attributedURL.CLS;
        }
        return this._urlDocument.URL;
    }
}

export { WebVitalsInstrumentation };
//# sourceMappingURL=WebVitalsInstrumentation.js.map
