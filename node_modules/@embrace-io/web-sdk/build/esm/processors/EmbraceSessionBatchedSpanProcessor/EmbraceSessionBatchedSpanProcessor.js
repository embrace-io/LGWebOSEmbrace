import { BindOnceFuture, internal, ExportResultCode } from '@opentelemetry/core';
import { EmbraceProcessor } from '../EmbraceProcessor/EmbraceProcessor.js';
import { EmbraceSpanStorage } from '../../utils/EmbraceSpanStorage/EmbraceSpanStorage.js';
import { KEY_EMB_TYPE, EMB_TYPES } from '../../constants/attributes.js';

const isSessionSpan = (span)=>span.attributes[KEY_EMB_TYPE] === EMB_TYPES.Session;
class EmbraceSessionBatchedSpanProcessor extends EmbraceProcessor {
    constructor({ exporter, limitManager, storage = window.localStorage, storedSpansExpireTimeoutMS, ...parentArgs }){
        super({
            ...parentArgs,
            processorName: 'EmbraceSessionBatchedSpanProcessor'
        }), this._pendingSpans = [], this._shutdown = ()=>{
            this._spanStorage.destroy();
            return this._exporter.shutdown();
        };
        this._exporter = exporter;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        this._limitManager = limitManager;
        this._spanStorage = new EmbraceSpanStorage({
            storage,
            diag: parentArgs.diag,
            onExpiredSpansExport: (spans)=>{
                this._exportSpans(spans);
            },
            storedSpansExpireTimeoutMS
        });
    }
    forceFlush() {
        this.diag.debug('forceFlush called for EmbraceSessionBatchedSpanProcessor. This is a no op');
        return Promise.resolve(undefined);
    }
    onEnd(span) {
        if (this._shutdownOnce.isCalled) {
            this.diag.debug('span ended after processor shutdown. Ignoring span.');
            return;
        }
        if (!isSessionSpan(span)) {
            this.diag.debug('non-session span ended. Adding to pending spans queue.');
            if (this._limitManager.dropReadableSpan(span)) {
                return;
            }
            this._pendingSpans.push(span);
        } else {
            this.diag.debug('session span ended. Exporting all pending spans.');
            this._exportSpans([
                span,
                ...this._pendingSpans
            ]);
            this._pendingSpans = [];
        }
    }
    _exportSpans(spans) {
        internal._export(this._exporter, spans).then((result)=>{
            if (result.code === ExportResultCode.FAILED) {
                this.diag.error(`spans failed to export: ${result.error?.message || 'unknown error'}`);
            }
        })// Seems like everything related to the export logic does a good job of catching and only ever resolving with
        // an ExportResult even on failure: https://github.com/open-telemetry/opentelemetry-js/blob/cf6dffeebcf72c42b2cb4d2bf2db720369b53081/packages/opentelemetry-core/src/internal/exporter.ts#L37
        // Keep this block just in case that assumption changes in a future version
        .catch((reason)=>{
            let msg = 'unknown error';
            if (reason && reason instanceof Error) {
                msg = reason.message;
            } else if (typeof reason === 'string') {
                msg = reason;
            }
            this.diag.error(`spans failed to export: ${msg}`);
        });
    }
    onStart() {
    // do nothing.
    }
    getPendingSpansCount() {
        return this._pendingSpans.length;
    }
    storePendingSpans(sessionId, sessionSpan) {
        this._spanStorage.storePendingSpans(sessionId, sessionSpan, this._pendingSpans);
    }
    clearStoredSpans(sessionId) {
        this._spanStorage.clearStoredSpans(sessionId);
    }
    shutdown() {
        return this._shutdownOnce.call();
    }
}

export { EmbraceSessionBatchedSpanProcessor };
//# sourceMappingURL=EmbraceSessionBatchedSpanProcessor.js.map
