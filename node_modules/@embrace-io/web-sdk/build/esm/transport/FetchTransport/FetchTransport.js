class FetchTransport {
    constructor(_config){
        this._config = _config;
    }
    // _compressRequest compresses the data using the gzip algorithm.
    // Embrace Data endpoints require the data to be compressed.
    static async _compressRequest(data) {
        const stream = new CompressionStream('gzip');
        const writer = stream.writable.getWriter();
        void writer.write(data);
        void writer.close();
        const compressedChunks = [];
        const reader = stream.readable.getReader();
        let done = false;
        while(!done){
            const result = await reader.read();
            if (result.value) {
                compressedChunks.push(result.value);
            }
            done = result.done;
        }
        const compressedData = new Uint8Array(compressedChunks.reduce((acc, chunk)=>acc + chunk.length, 0));
        let offset = 0;
        for (const chunk of compressedChunks){
            compressedData.set(chunk, offset);
            offset += chunk.length;
        }
        return compressedData;
    }
    send(data, timeoutMillis) {
        return this._asyncSend(data, timeoutMillis);
    }
    shutdown() {
    // Intentionally left empty, nothing to do.
    }
    async _asyncSend(data, timeoutMillis) {
        let request = data;
        const headers = {
            'Content-Type': 'application/json',
            ...this._config.headers
        };
        if (this._config.compression === 'gzip') {
            request = await FetchTransport._compressRequest(data);
            headers['Content-Encoding'] = 'gzip';
            headers['Content-Length'] = request.length.toString();
        }
        try {
            const response = await fetch(this._config.url, {
                method: 'POST',
                keepalive: true,
                headers,
                body: request,
                signal: AbortSignal.timeout(timeoutMillis)
            });
            if (response.ok) {
                return {
                    status: 'success'
                };
            } else {
                return {
                    status: 'failure',
                    error: new Error('Fetch request failed')
                };
            }
        } catch  {
            return {
                status: 'failure',
                error: new Error('Fetch request errored')
            };
        }
    }
}

export { FetchTransport };
//# sourceMappingURL=FetchTransport.js.map
