import { diag } from '@opentelemetry/api';
import { KEY_EMB_TYPE, EMB_TYPES } from '../../constants/attributes.js';

const LogSeverityToLimitType = {
    info: 'info_log',
    warning: 'warning_log',
    error: 'error_log'
};
class EmbraceLimitManager {
    constructor({ diag: diagParam, maxAllowed, maxLength, maxAttributes }){
        this._diagnosticCounts = {};
        this._currentCount = {
            exception: 0,
            error_log: 0,
            warning_log: 0,
            info_log: 0,
            breadcrumb: 0,
            session_property: 0,
            span: 0,
            network_request: 0
        };
        this._diag = diagParam ?? diag.createComponentLogger({
            namespace: 'EmbraceLimitManager'
        });
        this._maxAllowed = maxAllowed;
        this._maxLength = maxLength;
        this._maxAttributes = maxAttributes;
    }
    _dropIfMaxReached(type) {
        if (this._currentCount[type] >= this._maxAllowed[type]) {
            this._diag.warn(`disallowing ${type} because the maximum number of ${this._maxAllowed[type].toString()} has already been reached for this session`);
            this._incrDiagnosticCount(type, 'drop');
            return true;
        }
        this._currentCount[type] = (this._currentCount[type] || 0) + 1;
        return false;
    }
    truncateString(type, body) {
        if (body.length > this._maxLength[type]) {
            this._diag.warn(`truncating ${type} because it is longer than ${this._maxLength[type].toString()} characters: "${body}"`);
            this._incrDiagnosticCount(type, 'truncate_string');
            return body.substring(0, this._maxLength[type]);
        }
        return body;
    }
    _truncateAttributes(type, attributes, keyType, valueType) {
        const keys = Object.keys(attributes);
        if (keys.length > this._maxAttributes[type]) {
            this._diag.warn(`truncating ${type} attributes because there are more than ${this._maxAttributes[type].toString()} set`);
            this._incrDiagnosticCount(type, 'truncate_attributes');
        }
        const truncatedAttributes = {};
        for(let i = 0; i < Math.min(keys.length, this._maxAttributes[type]); i++){
            const truncatedKey = this.truncateString(keyType, keys[i]);
            truncatedAttributes[truncatedKey] = this.truncateString(valueType, attributes[keys[i]]?.toString() || '');
        }
        return truncatedAttributes;
    }
    limitBreadcrumb(name) {
        if (this._dropIfMaxReached('breadcrumb')) {
            return 'dropped';
        }
        return {
            name: this.truncateString('breadcrumb', name)
        };
    }
    limitException(message, attributes) {
        if (this._dropIfMaxReached('exception')) {
            return 'dropped';
        }
        return {
            message: this.truncateString('exception', message),
            attributes: this._truncateAttributes('exception', attributes, 'exception_attribute_key', 'exception_attribute_value')
        };
    }
    limitLog(message, severity, attributes) {
        const logType = LogSeverityToLimitType[severity];
        if (this._dropIfMaxReached(logType)) {
            return 'dropped';
        }
        return {
            message: this.truncateString(logType, message),
            attributes: this._truncateAttributes(logType, attributes, 'log_attribute_key', 'log_attribute_value')
        };
    }
    limitSessionProperty(key, value) {
        if (this._dropIfMaxReached('session_property')) {
            return 'dropped';
        }
        return {
            key: this.truncateString('session_property_key', key),
            value: this.truncateString('session_property_value', value)
        };
    }
    dropReadableSpan(span) {
        const type = span.attributes[KEY_EMB_TYPE] === EMB_TYPES.Network ? 'network_request' : 'span';
        return this._dropIfMaxReached(type);
    }
    reset() {
        this._diagnosticCounts = {};
        this._currentCount = {
            exception: 0,
            error_log: 0,
            warning_log: 0,
            info_log: 0,
            breadcrumb: 0,
            session_property: 0,
            span: 0,
            network_request: 0
        };
    }
    _incrDiagnosticCount(type, operation) {
        const key = `emb.app.applied_limit.${type}.${operation}.count`;
        this._diagnosticCounts[key] = (this._diagnosticCounts[key] || 0) + 1;
    }
    getDiagnosticCounts() {
        return this._diagnosticCounts;
    }
}

export { EmbraceLimitManager };
//# sourceMappingURL=EmbraceLimitManager.js.map
