import { diag } from '@opentelemetry/api';
import { logs, SeverityNumber } from '@opentelemetry/api-logs';
import { ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_TYPE } from '@opentelemetry/semantic-conventions';
import { KEY_EMB_UNHANDLED_EXCEPTIONS_COUNT, EMB_TYPES, KEY_EMB_JS_FILE_BUNDLE_IDS, KEY_EMB_EXCEPTION_HANDLING, KEY_EMB_TYPE, KEY_EMB_ERROR_LOG_COUNT, KEY_EMB_JS_EXCEPTION_STACKTRACE } from '../../constants/attributes.js';
import { OTelPerformanceManager } from '../../utils/PerformanceManager/OTelPerformanceManager.js';
import { GLOBAL_CONFIG } from '../../utils/globalConfig.js';

/**
 * GLOBAL_CONFIG._EmbraceFileBundleIDs is populated on run time when each file is loaded,
 * based on the contents that were injected by the embrace-web-cli.
 */ const getJSFileBundleIDs = ()=>JSON.stringify(GLOBAL_CONFIG._EmbraceFileBundleIDs || {});
class EmbraceLogManager {
    constructor({ diag: diagParam, perf, spanSessionManager, limitManager, loggerProvider: globalLoggerProviderOverride }){
        const loggerProvider = globalLoggerProviderOverride ?? logs;
        this._diag = diagParam ?? diag.createComponentLogger({
            namespace: 'EmbraceLogManager'
        });
        this._perf = perf ?? new OTelPerformanceManager();
        this._logger = loggerProvider.getLogger('embrace-web-sdk-logs');
        this._spanSessionManager = spanSessionManager;
        this._limitManager = limitManager;
    }
    static _logSeverityToSeverityNumber(severity) {
        switch(severity){
            case 'info':
                return SeverityNumber.INFO;
            case 'warning':
                return SeverityNumber.WARN;
            default:
                return SeverityNumber.ERROR;
        }
    }
    logException(error, { handled = true, attributes = {}, timestamp = this._perf.getNowMillis() } = {}) {
        if (!error) {
            error = new Error('logException received an undefined error');
        }
        // real user input may be null but TS doesn't know that
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (attributes == null || typeof attributes !== 'object') {
            this._diag.warn('attributes must be a non-null object', attributes);
            attributes = {};
        }
        if (!handled) {
            this._spanSessionManager.incrSessionCountForKey(KEY_EMB_UNHANDLED_EXCEPTIONS_COUNT);
        }
        const normalizedError = EmbraceLogManager._normalizeErrorData(error);
        const limitedException = this._limitManager.limitException(normalizedError.message, attributes);
        if (limitedException === 'dropped') {
            return;
        }
        this._logger.emit({
            timestamp,
            severityNumber: SeverityNumber.ERROR,
            severityText: 'ERROR',
            body: limitedException.message,
            attributes: {
                ...limitedException.attributes,
                [KEY_EMB_TYPE]: EMB_TYPES.SystemException,
                [KEY_EMB_EXCEPTION_HANDLING]: handled ? 'HANDLED' : 'UNHANDLED',
                [ATTR_EXCEPTION_TYPE]: normalizedError.type,
                ['exception.name']: normalizedError.name,
                [ATTR_EXCEPTION_MESSAGE]: limitedException.message,
                [ATTR_EXCEPTION_STACKTRACE]: normalizedError.stack,
                [KEY_EMB_JS_FILE_BUNDLE_IDS]: getJSFileBundleIDs()
            }
        });
    }
    message(message, severity, { attributes = {}, includeStacktrace = true, stacktrace } = {}) {
        if (!message || typeof message !== 'string') {
            this._diag.warn('Message must be a string');
            return;
        }
        if (severity === 'error') {
            this._spanSessionManager.incrSessionCountForKey(KEY_EMB_ERROR_LOG_COUNT);
        }
        let stacktraceString = '';
        if (severity !== 'info') {
            if (stacktrace) {
                stacktraceString = stacktrace;
            } else if (includeStacktrace) {
                stacktraceString = new Error().stack || '';
            }
        }
        this._logMessage({
            message: message.trim(),
            severity,
            timestamp: this._perf.getNowMillis(),
            attributes,
            stacktrace: stacktraceString
        });
    }
    _logMessage({ message, severity, timestamp, attributes = {}, stacktrace }) {
        const limitedLog = this._limitManager.limitLog(message, severity, attributes);
        if (limitedLog === 'dropped') {
            return;
        }
        this._logger.emit({
            timestamp,
            severityNumber: EmbraceLogManager._logSeverityToSeverityNumber(severity),
            severityText: severity.toUpperCase(),
            body: limitedLog.message,
            attributes: {
                ...limitedLog.attributes,
                [KEY_EMB_TYPE]: EMB_TYPES.SystemLog,
                ...stacktrace ? {
                    [KEY_EMB_JS_EXCEPTION_STACKTRACE]: stacktrace,
                    [KEY_EMB_JS_FILE_BUNDLE_IDS]: getJSFileBundleIDs()
                } : {}
            }
        });
    }
    static _normalizeErrorData(error) {
        if (error instanceof Error) {
            return {
                message: typeof error.message === 'string' ? error.message.trim() : '',
                type: error.constructor.name,
                name: error.name,
                stack: error.stack || ''
            };
        }
        // For non-Error types, generate a new stack trace
        const userCallStack = new Error().stack || '';
        if (typeof error === 'string') {
            return {
                message: error.trim(),
                type: 'String',
                name: 'String',
                stack: userCallStack
            };
        }
        if (error && typeof error === 'object') {
            let message = '';
            try {
                message = JSON.stringify(error);
            } catch  {
                message = '[unable to serialize error]';
            }
            return {
                message,
                type: error.constructor.name,
                name: error.constructor.name,
                stack: userCallStack
            };
        }
        return {
            message: String(error).trim(),
            type: typeof error,
            name: typeof error,
            stack: userCallStack
        };
    }
}

export { EmbraceLogManager };
//# sourceMappingURL=EmbraceLogManager.js.map
