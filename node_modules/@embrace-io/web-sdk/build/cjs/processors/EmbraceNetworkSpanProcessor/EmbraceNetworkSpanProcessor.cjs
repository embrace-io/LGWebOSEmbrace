'use strict';

var semanticConventions = require('@opentelemetry/semantic-conventions');
var incubating = require('@opentelemetry/semantic-conventions/incubating');
var types = require('./types.cjs');
var attributes = require('../../constants/attributes.cjs');

/**
 * Embrace's API expects network spans to have some specific attributes.
 * This processor checks if a span is a network span and adds them.
 */ class EmbraceNetworkSpanProcessor {
    forceFlush() {
        return Promise.resolve(undefined);
    }
    // TODO `onEnd` is not supposed to modify the span. There is a new experimental onEnding api that allows modifying
    //  the span before it is sent to the exporter. This processor should be updated to use that api once that is available
    onEnd(span) {
        if (types.isNetworkSpan(span)) {
            span.attributes[attributes.KEY_EMB_TYPE] = attributes.EMB_TYPES.Network;
            /*
        Fallback on deprecated attribute names in case the span is using those instead of the latest ones

        The current versions of @opentelemetry/instrumentation-xml-http-request and @opentelemetry/instrumentation-fetch
        that we're getting from @opentelemetry/auto-instrumentations-web are using these, once we update we'll remove
        this fallback and only support a single version of the semantic convention
       */ // eslint-disable-next-line @typescript-eslint/no-deprecated
            span.attributes[semanticConventions.ATTR_URL_FULL] ??= span.attributes[semanticConventions.SEMATTRS_HTTP_URL];
            span.attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] ??= span.attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];
            span.attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] ??= span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD];
            span.attributes[incubating.ATTR_HTTP_RESPONSE_BODY_SIZE] ??= span.attributes[semanticConventions.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH];
            span.attributes[incubating.ATTR_HTTP_REQUEST_BODY_SIZE] ??= span.attributes[semanticConventions.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH];
        }
    }
    onStart() {
    // do nothing.
    }
    shutdown() {
        return Promise.resolve(undefined);
    }
}

exports.EmbraceNetworkSpanProcessor = EmbraceNetworkSpanProcessor;
//# sourceMappingURL=EmbraceNetworkSpanProcessor.cjs.map
