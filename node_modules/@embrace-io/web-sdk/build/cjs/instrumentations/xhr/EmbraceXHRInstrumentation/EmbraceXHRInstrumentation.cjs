'use strict';

var instrumentation = require('@opentelemetry/instrumentation');
var instrumentationXmlHttpRequest = require('@opentelemetry/instrumentation-xml-http-request');

class EmbraceXHRInstrumentation extends instrumentationXmlHttpRequest.XMLHttpRequestInstrumentation {
    constructor({ omitIfAlreadyPatched, ...rest } = {}){
        // Base constructor automatically calls this.enable() if enabled is true, but we need to run our overridden constructor
        // first so force enabled false here and call it ourselves later
        super({
            ...rest,
            enabled: false
        });
        this._omitIfAlreadyPatched = omitIfAlreadyPatched;
        if (rest.enabled) {
            this.enable();
        }
    }
    enable() {
        // The base implementation always removes and then re-patches, this means the last instrumentation to run "wins":
        // https://github.com/open-telemetry/opentelemetry-js/blob/2d7eecbb19aec17bf2d8b9a4e4b2d84dc92c2d88/experimental/packages/opentelemetry-instrumentation-xml-http-request/src/xhr.ts#L639
        // Exposing an option in this class to allow leaving the existing patch in place and letting a previous instrumentation
        // control the global
        if (this._omitIfAlreadyPatched && // eslint-disable-next-line @typescript-eslint/unbound-method
        (instrumentation.isWrapped(XMLHttpRequest.prototype.open) || // eslint-disable-next-line @typescript-eslint/unbound-method
        instrumentation.isWrapped(XMLHttpRequest.prototype.send))) {
            this._diag.debug('XMLHttpRequest is already passed and `omitIfAlreadyPatched` is true, skipping enabling this instrumentation');
            return;
        }
        super.enable();
    }
}

exports.EmbraceXHRInstrumentation = EmbraceXHRInstrumentation;
//# sourceMappingURL=EmbraceXHRInstrumentation.cjs.map
