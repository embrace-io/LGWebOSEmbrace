'use strict';

var EmbraceInstrumentationBase = require('../../EmbraceInstrumentationBase/EmbraceInstrumentationBase.cjs');

class GlobalExceptionInstrumentation extends EmbraceInstrumentationBase.EmbraceInstrumentationBase {
    constructor({ diag, perf } = {}){
        super({
            instrumentationName: 'GlobalExceptionInstrumentation',
            instrumentationVersion: '1.0.0',
            diag,
            perf,
            config: {}
        });
        this._onErrorHandler = (event)=>{
            this.logManager.logException(event.error || event.message, {
                handled: false,
                timestamp: this.perf.epochMillisFromOriginOffset(event.timeStamp)
            });
        };
        this._onUnhandledRejectionHandler = (event)=>{
            let error;
            if (event.reason && event.reason instanceof Error) {
                error = event.reason;
            } else {
                error = new Error(typeof event.reason === 'string' ? event.reason : 'Unhandled Rejected Promise');
                error.stack = '';
            }
            this.logManager.logException(error, {
                handled: false,
                timestamp: this.perf.epochMillisFromOriginOffset(event.timeStamp)
            });
        };
        if (this._config.enabled) {
            this.enable();
        }
    }
    disable() {
        window.removeEventListener('error', this._onErrorHandler);
        window.removeEventListener('unhandledrejection', this._onUnhandledRejectionHandler);
    }
    enable() {
        window.addEventListener('error', this._onErrorHandler);
        window.addEventListener('unhandledrejection', this._onUnhandledRejectionHandler);
    }
}

exports.GlobalExceptionInstrumentation = GlobalExceptionInstrumentation;
//# sourceMappingURL=GlobalExceptionInstrumentation.cjs.map
