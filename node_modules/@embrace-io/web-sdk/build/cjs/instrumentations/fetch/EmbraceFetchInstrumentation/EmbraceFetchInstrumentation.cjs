'use strict';

var instrumentationFetch = require('@opentelemetry/instrumentation-fetch');
var instrumentation = require('@opentelemetry/instrumentation');

class EmbraceFetchInstrumentation extends instrumentationFetch.FetchInstrumentation {
    constructor({ omitIfAlreadyPatched, ...rest } = {}){
        // Base constructor automatically calls this.enable() if enabled is true, but we need to run our overridden constructor
        // first so force enabled false here and call it ourselves later
        super({
            ...rest,
            enabled: false
        });
        this._omitIfAlreadyPatched = omitIfAlreadyPatched;
        if (rest.enabled) {
            this.enable();
        }
    }
    enable() {
        // The base implementation always removes and then re-patches, this means the last instrumentation to run "wins":
        // https://github.com/open-telemetry/opentelemetry-js/blob/2d7eecbb19aec17bf2d8b9a4e4b2d84dc92c2d88/experimental/packages/opentelemetry-instrumentation-fetch/src/fetch.ts#L604
        // Exposing an option in this class to allow leaving the existing patch in place and letting a previous instrumentation
        // control the global
        if (this._omitIfAlreadyPatched && instrumentation.isWrapped(fetch)) {
            this._diag.debug('fetch is already passed and `omitIfAlreadyPatched` is true, skipping enabling this instrumentation');
            return;
        }
        super.enable();
    }
}

exports.EmbraceFetchInstrumentation = EmbraceFetchInstrumentation;
//# sourceMappingURL=EmbraceFetchInstrumentation.cjs.map
