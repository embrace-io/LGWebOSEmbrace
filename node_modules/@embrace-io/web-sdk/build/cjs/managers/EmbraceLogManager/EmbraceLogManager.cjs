'use strict';

var api = require('@opentelemetry/api');
var apiLogs = require('@opentelemetry/api-logs');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var attributes = require('../../constants/attributes.cjs');
var OTelPerformanceManager = require('../../utils/PerformanceManager/OTelPerformanceManager.cjs');
var globalConfig = require('../../utils/globalConfig.cjs');

/**
 * GLOBAL_CONFIG._EmbraceFileBundleIDs is populated on run time when each file is loaded,
 * based on the contents that were injected by the embrace-web-cli.
 */ const getJSFileBundleIDs = ()=>JSON.stringify(globalConfig.GLOBAL_CONFIG._EmbraceFileBundleIDs || {});
class EmbraceLogManager {
    constructor({ diag: diagParam, perf, spanSessionManager, limitManager, loggerProvider: globalLoggerProviderOverride }){
        const loggerProvider = globalLoggerProviderOverride ?? apiLogs.logs;
        this._diag = diagParam ?? api.diag.createComponentLogger({
            namespace: 'EmbraceLogManager'
        });
        this._perf = perf ?? new OTelPerformanceManager.OTelPerformanceManager();
        this._logger = loggerProvider.getLogger('embrace-web-sdk-logs');
        this._spanSessionManager = spanSessionManager;
        this._limitManager = limitManager;
    }
    static _logSeverityToSeverityNumber(severity) {
        switch(severity){
            case 'info':
                return apiLogs.SeverityNumber.INFO;
            case 'warning':
                return apiLogs.SeverityNumber.WARN;
            default:
                return apiLogs.SeverityNumber.ERROR;
        }
    }
    logException(error, { handled = true, attributes: attributes$1 = {}, timestamp = this._perf.getNowMillis() } = {}) {
        if (!error) {
            error = new Error('logException received an undefined error');
        }
        // real user input may be null but TS doesn't know that
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (attributes$1 == null || typeof attributes$1 !== 'object') {
            this._diag.warn('attributes must be a non-null object', attributes$1);
            attributes$1 = {};
        }
        if (!handled) {
            this._spanSessionManager.incrSessionCountForKey(attributes.KEY_EMB_UNHANDLED_EXCEPTIONS_COUNT);
        }
        const normalizedError = EmbraceLogManager._normalizeErrorData(error);
        const limitedException = this._limitManager.limitException(normalizedError.message, attributes$1);
        if (limitedException === 'dropped') {
            return;
        }
        this._logger.emit({
            timestamp,
            severityNumber: apiLogs.SeverityNumber.ERROR,
            severityText: 'ERROR',
            body: limitedException.message,
            attributes: {
                ...limitedException.attributes,
                [attributes.KEY_EMB_TYPE]: attributes.EMB_TYPES.SystemException,
                [attributes.KEY_EMB_EXCEPTION_HANDLING]: handled ? 'HANDLED' : 'UNHANDLED',
                [semanticConventions.ATTR_EXCEPTION_TYPE]: normalizedError.type,
                ['exception.name']: normalizedError.name,
                [semanticConventions.ATTR_EXCEPTION_MESSAGE]: limitedException.message,
                [semanticConventions.ATTR_EXCEPTION_STACKTRACE]: normalizedError.stack,
                [attributes.KEY_EMB_JS_FILE_BUNDLE_IDS]: getJSFileBundleIDs()
            }
        });
    }
    message(message, severity, { attributes: attributes$1 = {}, includeStacktrace = true, stacktrace } = {}) {
        if (!message || typeof message !== 'string') {
            this._diag.warn('Message must be a string');
            return;
        }
        if (severity === 'error') {
            this._spanSessionManager.incrSessionCountForKey(attributes.KEY_EMB_ERROR_LOG_COUNT);
        }
        let stacktraceString = '';
        if (severity !== 'info') {
            if (stacktrace) {
                stacktraceString = stacktrace;
            } else if (includeStacktrace) {
                stacktraceString = new Error().stack || '';
            }
        }
        this._logMessage({
            message: message.trim(),
            severity,
            timestamp: this._perf.getNowMillis(),
            attributes: attributes$1,
            stacktrace: stacktraceString
        });
    }
    _logMessage({ message, severity, timestamp, attributes: attributes$1 = {}, stacktrace }) {
        const limitedLog = this._limitManager.limitLog(message, severity, attributes$1);
        if (limitedLog === 'dropped') {
            return;
        }
        this._logger.emit({
            timestamp,
            severityNumber: EmbraceLogManager._logSeverityToSeverityNumber(severity),
            severityText: severity.toUpperCase(),
            body: limitedLog.message,
            attributes: {
                ...limitedLog.attributes,
                [attributes.KEY_EMB_TYPE]: attributes.EMB_TYPES.SystemLog,
                ...stacktrace ? {
                    [attributes.KEY_EMB_JS_EXCEPTION_STACKTRACE]: stacktrace,
                    [attributes.KEY_EMB_JS_FILE_BUNDLE_IDS]: getJSFileBundleIDs()
                } : {}
            }
        });
    }
    static _normalizeErrorData(error) {
        if (error instanceof Error) {
            return {
                message: typeof error.message === 'string' ? error.message.trim() : '',
                type: error.constructor.name,
                name: error.name,
                stack: error.stack || ''
            };
        }
        // For non-Error types, generate a new stack trace
        const userCallStack = new Error().stack || '';
        if (typeof error === 'string') {
            return {
                message: error.trim(),
                type: 'String',
                name: 'String',
                stack: userCallStack
            };
        }
        if (error && typeof error === 'object') {
            let message = '';
            try {
                message = JSON.stringify(error);
            } catch  {
                message = '[unable to serialize error]';
            }
            return {
                message,
                type: error.constructor.name,
                name: error.constructor.name,
                stack: userCallStack
            };
        }
        return {
            message: String(error).trim(),
            type: typeof error,
            name: typeof error,
            stack: userCallStack
        };
    }
}

exports.EmbraceLogManager = EmbraceLogManager;
//# sourceMappingURL=EmbraceLogManager.cjs.map
