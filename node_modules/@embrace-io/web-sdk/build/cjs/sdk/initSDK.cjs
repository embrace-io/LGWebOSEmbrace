'use strict';

var api = require('@opentelemetry/api');
var apiLogs = require('@opentelemetry/api-logs');
var instrumentation = require('@opentelemetry/instrumentation');
var resources = require('@opentelemetry/resources');
var sdkLogs = require('@opentelemetry/sdk-logs');
var sdkTraceWeb = require('@opentelemetry/sdk-trace-web');
var utils = require('./utils.cjs');
var setupDefaultInstrumentations = require('./setupDefaultInstrumentations.cjs');
var webCommon = require('@opentelemetry/web-common');
var registry = require('./registry.cjs');
var defaultAttributeScrubbers = require('./defaultAttributeScrubbers.cjs');
var OTelPerformanceManager = require('../utils/PerformanceManager/OTelPerformanceManager.cjs');
var webSdkResource = require('../resources/webSdkResource.cjs');
var EmbraceDynamicConfigManager = require('../managers/EmbraceConfigManager/EmbraceDynamicConfigManager.cjs');
var EmbraceSDKFeaturesManager = require('../managers/EmbraceSDKFeaturesManager/EmbraceSDKFeaturesManager.cjs');
var nsfConfigValidation = require('../utils/nsfConfigValidation.cjs');
var EmbraceLimitManager = require('../managers/EmbraceLimitManager/EmbraceLimitManager.cjs');
var constants = require('../managers/EmbraceLimitManager/constants.cjs');
var EmbraceSessionBatchedSpanProcessor = require('../processors/EmbraceSessionBatchedSpanProcessor/EmbraceSessionBatchedSpanProcessor.cjs');
var EmbraceTraceExporter = require('../exporters/EmbraceTraceExporter/EmbraceTraceExporter.cjs');
var EmbraceLogExporter = require('../exporters/EmbraceLogExporter/EmbraceLogExporter.cjs');
var EmbraceW3CTraceContextPropagator = require('../propagators/EmbraceW3CTraceContextPropagator/EmbraceW3CTraceContextPropagator.cjs');
var EmbraceUserManager = require('../managers/EmbraceUserManager/EmbraceUserManager.cjs');
var userAPI = require('../api-users/userAPI.cjs');
var EmbraceSpanSessionManager = require('../managers/EmbraceSpanSessionManager/EmbraceSpanSessionManager.cjs');
var sessionAPI = require('../api-sessions/sessionAPI.cjs');
var EmbraceNetworkSpanProcessor = require('../processors/EmbraceNetworkSpanProcessor/EmbraceNetworkSpanProcessor.cjs');
var UserSpanProcessor = require('../processors/UserSpanProcessor/UserSpanProcessor.cjs');
var SpanScrubProcessor = require('../processors/SpanScrubProcessor/SpanScrubProcessor.cjs');
var EmbraceTraceManager = require('../managers/EmbraceTraceManager/EmbraceTraceManager.cjs');
var traceAPI = require('../api-traces/traceAPI.cjs');
var IdentifiableSessionLogRecordProcessor = require('../processors/IdentifiableSessionLogRecordProcessor/IdentifiableSessionLogRecordProcessor.cjs');
var EmbraceLogRecordProcessor = require('../processors/EmbraceLogRecordProcessor/EmbraceLogRecordProcessor.cjs');
var UserLogRecordProcessor = require('../processors/UserLogRecordProcessor/UserLogRecordProcessor.cjs');
var LogRecordScrubProcessor = require('../processors/LogRecordScrubProcessor/LogRecordScrubProcessor.cjs');
var EmbraceLogManager = require('../managers/EmbraceLogManager/EmbraceLogManager.cjs');
var logAPI = require('../api-logs/logAPI.cjs');

const initSDK = ({ appID, appVersion, resource = resources.emptyResource(), spanExporters = [], logExporters = [], spanProcessors = [], propagator = null, defaultInstrumentationConfig, instrumentations = [], contextManager = null, logProcessors = [], attributeScrubbers = [], enableDefaultAttributeScrubbing = true, additionalQueryParamsToScrub = [], logLevel = api.DiagLogLevel.ERROR, embraceDataURL, embraceConfigURL, diagLogger = api.diag.createComponentLogger({
    namespace: 'embrace-sdk'
}), dynamicSDKConfigManager: providedDynamicSDKConfigManager, dynamicSDKConfig, registerGlobally = true, blockNetworkSpanForwarding = false } = {
    appID: ''
})=>{
    try {
        const perf = new OTelPerformanceManager.OTelPerformanceManager();
        const initSDKStart = perf.getNowMillis();
        if (registerGlobally) {
            const existingSDK = registry.registry.registered();
            if (existingSDK !== null) {
                diagLogger.warn('SDK has already been successfully initialized, skipping this invocation of initSDK');
                return existingSDK;
            }
        }
        api.diag.setLogger(new api.DiagConsoleLogger(), {
            logLevel
        });
        const resourceWithWebSDKAttributes = resource.merge(webSdkResource.getWebSDKResource({
            diagLogger,
            appVersion,
            pageSessionStorage: window.sessionStorage
        }));
        const sendingToEmbrace = !!appID && utils.isValidAppID(appID);
        if (!sendingToEmbrace && !logExporters.length && !spanExporters.length) {
            throw new Error('when the embrace appID is omitted then at least one logExporter or spanExporter must be set');
        }
        const userManager = setupUser({
            registerGlobally
        });
        const enduserPseudoID = userManager.getEmbraceUserId();
        if (sendingToEmbrace && !enduserPseudoID) {
            throw new Error('userID is required when using Embrace exporter');
        }
        const dynamicConfigManager = providedDynamicSDKConfigManager ?? new EmbraceDynamicConfigManager.EmbraceDynamicConfigManager({
            appID,
            appVersion,
            embraceConfigURL,
            defaultConfig: dynamicSDKConfig,
            deviceId: enduserPseudoID
        });
        void dynamicConfigManager.refreshRemoteConfig();
        const sdkFeaturesManager = new EmbraceSDKFeaturesManager.EmbraceSDKFeaturesManager({
            dynamicConfigManager,
            deviceId: enduserPseudoID,
            blockNetworkSpanForwarding
        });
        if (!sdkFeaturesManager.isSDKEnabled()) {
            diagLogger.debug('SDK is disabled, skipping initialization.');
            return false;
        }
        const nsfValid = nsfConfigValidation.nsfConfigValidation({
            featureManager: sdkFeaturesManager,
            diag: diagLogger,
            registerGlobally,
            defaultInstrumentationConfig,
            propagator
        });
        const limitManager = new EmbraceLimitManager.EmbraceLimitManager(constants.DEFAULT_LIMITS);
        const finalAttributeScrubbers = [
            ...enableDefaultAttributeScrubbing ? defaultAttributeScrubbers.getDefaultAttributeScrubbers(additionalQueryParamsToScrub) : [],
            ...attributeScrubbers
        ];
        const spanSessionManager = setupSession({
            limitManager,
            registerGlobally
        });
        let embraceSpanProcessor;
        let embraceLogProcessor;
        if (sendingToEmbrace) {
            embraceSpanProcessor = new EmbraceSessionBatchedSpanProcessor.EmbraceSessionBatchedSpanProcessor({
                exporter: new EmbraceTraceExporter.EmbraceTraceExporter({
                    appID,
                    embraceDataURL,
                    userID: enduserPseudoID
                }),
                limitManager,
                storedSpansExpireTimeoutMS: defaultInstrumentationConfig?.['session-visibility']?.storedSpansExpireTimeoutMS
            });
            embraceLogProcessor = new sdkLogs.BatchLogRecordProcessor(new EmbraceLogExporter.EmbraceLogExporter({
                appID,
                embraceDataURL,
                userID: enduserPseudoID
            }));
        }
        const { tracerProvider, embraceTraceManager } = setupTraces({
            resource: resourceWithWebSDKAttributes,
            spanSessionManager,
            userManager,
            spanExporters,
            spanProcessors,
            propagator: nsfValid ? new EmbraceW3CTraceContextPropagator.EmbraceW3CTraceContextPropagator() : propagator,
            contextManager,
            attributeScrubbers: finalAttributeScrubbers,
            registerGlobally,
            embraceSpanProcessor
        });
        spanSessionManager.setTracerProvider(tracerProvider);
        const { loggerProvider, embraceLogManager } = setupLogs({
            resource: resourceWithWebSDKAttributes,
            userManager,
            logExporters,
            logProcessors,
            spanSessionManager,
            limitManager,
            attributeScrubbers: finalAttributeScrubbers,
            registerGlobally,
            embraceLogProcessor
        });
        // NOTE: we require setupInstrumentation to run the last, after setupLogs and setupTraces. This is how OTel works wrt
        // the dependencies between instrumentations and global providers. We need the providers for tracers, and logs to be
        // setup before we enable instrumentations.
        if (!registerGlobally) {
            instrumentation.registerInstrumentations({
                tracerProvider,
                loggerProvider,
                instrumentations: [
                    setupDefaultInstrumentations.setupDefaultInstrumentations(defaultInstrumentationConfig, {
                        logManager: embraceLogManager,
                        spanSessionManager,
                        embraceSpanProcessor
                    }),
                    ...instrumentations
                ]
            });
        } else {
            instrumentation.registerInstrumentations({
                instrumentations: [
                    setupDefaultInstrumentations.setupDefaultInstrumentations(defaultInstrumentationConfig, {
                        embraceSpanProcessor
                    }),
                    ...instrumentations
                ]
            });
        }
        diagLogger.info('successfully initialized the SDK');
        const sdkControl = {
            setDynamicConfig: (config)=>{
                dynamicConfigManager.setConfig(config);
            },
            flush: async ()=>{
                await tracerProvider.forceFlush();
                await loggerProvider.forceFlush();
            },
            log: embraceLogManager,
            trace: embraceTraceManager,
            session: spanSessionManager,
            user: userManager
        };
        if (registerGlobally) {
            registry.registry.register(sdkControl);
        }
        spanSessionManager.recordSDKStartupDuration(perf.getNowMillis() - initSDKStart);
        return sdkControl;
    } catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown error.';
        diagLogger.error(`failed to initialize the SDK: ${message}`);
        return false;
    }
};
const setupUser = ({ registerGlobally })=>{
    const embraceUserManager = new EmbraceUserManager.EmbraceUserManager();
    if (registerGlobally) {
        userAPI.user.setGlobalUserManager(embraceUserManager);
    }
    return embraceUserManager;
};
const setupSession = ({ limitManager, registerGlobally })=>{
    const embraceSpanSessionManager = new EmbraceSpanSessionManager.EmbraceSpanSessionManager({
        limitManager
    });
    if (registerGlobally) {
        sessionAPI.session.setGlobalSessionManager(embraceSpanSessionManager);
    }
    return embraceSpanSessionManager;
};
const setupTraces = ({ resource, spanSessionManager, userManager, spanExporters, spanProcessors = [], propagator = null, contextManager = null, attributeScrubbers, registerGlobally, embraceSpanProcessor })=>{
    const finalSpanProcessors = [
        ...spanProcessors,
        webCommon.createSessionSpanProcessor(spanSessionManager),
        new EmbraceNetworkSpanProcessor.EmbraceNetworkSpanProcessor(),
        new UserSpanProcessor.UserSpanProcessor({
            userManager
        }),
        new SpanScrubProcessor.SpanScrubProcessor({
            attributeScrubbers
        })
    ];
    spanExporters?.forEach((exporter)=>{
        finalSpanProcessors.push(new sdkTraceWeb.BatchSpanProcessor(exporter));
    });
    if (embraceSpanProcessor) {
        finalSpanProcessors.push(embraceSpanProcessor);
    }
    const tracerProvider = new sdkTraceWeb.WebTracerProvider({
        resource,
        spanProcessors: finalSpanProcessors,
        spanLimits: {
            // Session properties are stored as attributes on the session span, add a
            // buffer here so that there is room for our internal attributes
            attributeCountLimit: constants.DEFAULT_LIMITS.maxAllowed.session_property * 2,
            attributePerEventCountLimit: 20,
            // Breadcrumbs are stored as events on the session span, add a
            // buffer here so that there is room for our internal events
            eventCountLimit: constants.DEFAULT_LIMITS.maxAllowed.breadcrumb * 2,
            attributeValueLengthLimit: 1024
        }
    });
    const embraceTraceManager = new EmbraceTraceManager.EmbraceTraceManager({
        tracerProvider: registerGlobally ? undefined : tracerProvider
    });
    if (registerGlobally) {
        traceAPI.trace.setGlobalTraceManager(embraceTraceManager);
        tracerProvider.register({
            // WebTracerProvider.register has different fallback behaviours depending on whether null or undefined is passed,
            // be more explicit here and always supply a StackContextManager if the config did not specify one. If a user really
            // wants to turn off context management they can pass a no-op manager explicitly:
            // https://github.com/open-telemetry/opentelemetry-js/blob/4f0b6285af24b71a9fa022755aaa3b6a63ae5033/packages/opentelemetry-sdk-trace-web/src/WebTracerProvider.ts#L39
            contextManager: contextManager || new sdkTraceWeb.StackContextManager(),
            propagator
        });
    }
    return {
        tracerProvider,
        embraceTraceManager
    };
};
const setupLogs = ({ resource, userManager, logExporters, logProcessors, spanSessionManager, limitManager, attributeScrubbers, registerGlobally, embraceLogProcessor })=>{
    const finalLogProcessors = [
        ...logProcessors,
        new IdentifiableSessionLogRecordProcessor.IdentifiableSessionLogRecordProcessor({
            spanSessionManager
        }),
        new EmbraceLogRecordProcessor.EmbraceLogRecordProcessor(),
        new UserLogRecordProcessor.UserLogRecordProcessor({
            userManager
        }),
        new LogRecordScrubProcessor.LogRecordScrubProcessor({
            attributeScrubbers
        })
    ];
    logExporters?.forEach((exporter)=>{
        finalLogProcessors.push(new sdkLogs.BatchLogRecordProcessor(exporter));
    });
    if (embraceLogProcessor) {
        finalLogProcessors.push(embraceLogProcessor);
    }
    const loggerProvider = new sdkLogs.LoggerProvider({
        resource,
        processors: finalLogProcessors
    });
    const embraceLogManager = new EmbraceLogManager.EmbraceLogManager({
        spanSessionManager,
        limitManager,
        loggerProvider: registerGlobally ? undefined : loggerProvider
    });
    if (registerGlobally) {
        apiLogs.logs.setGlobalLoggerProvider(loggerProvider);
        logAPI.log.setGlobalLogManager(embraceLogManager);
    }
    return {
        loggerProvider,
        embraceLogManager
    };
};

exports.initSDK = initSDK;
//# sourceMappingURL=initSDK.cjs.map
